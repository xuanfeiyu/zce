# Part 3 · Vue.js 框架源码与进阶

## 模块四 · 搭建自己的SSR、静态站点生成（SSG）及封装 Vue.js 组件库

## 任务一：搭建自己的SSR

### 1.渲染一个 Vue 实例

- mkdir vue-ssr
- cd vue-ssr
- npm init -y
- npm i vue-server-renderer

```javascript
const Vue = require('vue)
const renderer = require('vue-server-renderer').createRenderer()
const app = new Vue({
  template: `
  <div id="app">
    <h1>{{ message }}</h1>
  </div>
  `
  data: {
    message: 'XXXX'
  }
})
renderer.renderToString(app, (err,html)=>{
  if(err) throw err
  console.log(html)
})
```

### 2.结合到 Web 服务器中

- npm i express

```javascript
const Vue = require('vue)
const express = require('express')
const renderer = require('vue-server-renderer').createRenderer()
const server = express()
server.get('/',(req,res)=>{
const app = new Vue({
  template: `
  <div id="app">
    <h1>{{ message }}</h1>
  </div>
  `
  data: {
    message: 'XXXX'
  }
})
renderer.renderToString(app, (err,html)=>{
  if(err) {
    return res.status(500).end('Internal Server Error.')
  }
  // res.setHeader('Content-Type','text/html;charset=utf8')
  res.end(`
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width,initial-scale=1.0">
      <title>Document</title>
    </head>
    <body>
      ${html}
    </body>
  </html>`)
})
})
server.listen(3000,()=>{
  console.log('server running at port 3000.)
})
```

### 3.使用 HTML 模板

```html
<!-- index.template.html -->
<!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width,initial-scale=1.0">
      <title>Document</title>
    </head>
    <body>
      <!-- vur-ssr-outlet -->
    </body>
</html>
```
```javascript
// server.js
const Vue = require('vue)
const express = require('express')
cosnst fs = require('fs')
const renderer = require('vue-server-renderer').createRenderer({
  template: fs.readFileSync('./index.template.html','utf-8')
})
const server = express()
server.get('/',(req,res)=>{
const app = new Vue({
  template: `
  <div id="app">
    <h1>{{ message }}</h1>
  </div>
  `
  data: {
    message: 'XXXX'
  }
})

renderer.renderToString(app, (err,html)=>{
  if(err) {
    return res.status(500).end('Internal Server Error.')
  }
  // res.setHeader('Content-Type','text/html;charset=utf8')
  res.end(html)
})
})
server.listen(3000,()=>{
  console.log('server running at port 3000.)
})
```

### 4.在模板中使用外部数据

```html
<!-- index.template.html -->
<!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width,initial-scale=1.0">
      {{{meta}}}
      <title>{{title}}</title>
    </head>
    <body>
      <!-- vur-ssr-outlet -->
    </body>
</html>
```

```javascript
// server.js
const Vue = require('vue)
const express = require('express')
cosnst fs = require('fs')
const renderer = require('vue-server-renderer').createRenderer({
  template: fs.readFileSync('./index.template.html','utf-8')
})
const server = express()
server.get('/',(req,res)=>{
const app = new Vue({
  template: `
  <div id="app">
    <h1>{{ message }}</h1>
  </div>
  `
  data: {
    message: 'XXXX'
  }
})

renderer.renderToString(app, {
  title: 'XXXX',
  meta: `<meta name="description" content="XXXX"`
}，(err,html)=>{
  if(err) {
    return res.status(500).end('Internal Server Error.')
  }
  // res.setHeader('Content-Type','text/html;charset=utf8')
  res.end(html)
})
})
server.listen(3000,()=>{
  console.log('server running at port 3000.)
})
```

### 5.构建配置-基本思路

```javascript
// server.js
const Vue = require('vue)
const express = require('express')
cosnst fs = require('fs')
const renderer = require('vue-server-renderer').createRenderer({
  template: fs.readFileSync('./index.template.html','utf-8')
})
const server = express()
server.get('/',(req,res)=>{
const app = new Vue({
  template: `
  <div id="app">
    <h1>{{ message }}</h1>
    <h2>客户端动态交互</h2>
    <div>
      <input v-model="message">
    </div>
    <div>
      <button @click="onClick">点击测试</button>
    </div>
  </div>
  `
  data: {
    message: 'XXXX'
  },
  methods: {
    onClick(){
      console.log('Hello World!')
    }
  }
})

renderer.renderToString(app, {
  title: 'XXXX',
  meta: `<meta name="description" content="XXXX"`
}，(err,html)=>{
  if(err) {
    return res.status(500).end('Internal Server Error.')
  }
  // res.setHeader('Content-Type','text/html;charset=utf8')
  res.end(html)
})
})
server.listen(3000,()=>{
  console.log('server running at port 3000.)
})
```

### 6.构建配置-源码结构

```html
 <!-- App.vue -->
<template>
  <div id="app">
    <h1>{{ message }}</h1>
    <h2>客户端动态交互</h2>
    <div>
      <input v-model="message">
    </div>
    <div>
      <button @click="onClick">点击测试</button>
    </div>
  </div>
</template>
<script>
export default {
  name: 'App',
  data(){
    return {
      message: 'XXXX'
    }
  },
  methods: {
    onClick(){
      console.log('Hello World!')
    }
  }
}
</script>
```
```javascript
// app.js
import Vue from 'vue'
import App from './App.vue'

// 导出一个工厂函数，用于创建新的
// 应用程序、router 和 store 实例
export function createApp () {
  const app = new Vue({
    // 根实例简单的渲染应用程序组件。
    render: h => h(App)
  })
  return { app }
}
```
```javascript
// entry-client.js
import { createApp } from './app'

// 客户端特定引导逻辑……

const { app } = createApp()

// 这里假定 App.vue 模板中根元素具有 `id="app"`
app.$mount('#app')
```
```javascript
// entry-server.js
import { createApp } from './app'

export default context => {
  const { app } = createApp()
  // 服务端路由处理、数据预取
  return app
}
```

### 7.构建配置-安装依赖

> 安装依赖

- 安装生产依赖
  - npm i vue vue-server-renderer express cross-env
    - vue Vue.js 核心库
    - vue-server-renderer Vue 服务端渲染工具
    - express 基于 Node 的 Web 服务框架
    - cross-env 通过 npm scripts 设置跨平台环境变量

- 安装开发依赖
  - npm i -D webpack webpack-cli webpack-merge webpack-node-externals @babel/core @babel/plugin-transform-runtime @babel/preset-env babel-loader css-loader url-loader file-loader rimraf vue-loader vue-template-compiler friendly-errors-webpack-plugin
    - webpack webpack 核心包
    - webpack-cli webpack 的命令行工具
    - webpack-merge webpack 配置信息合并工具
    - webpack-node-externals 排除 webpack 中的 Node 模块
    - rimraf 基于 Node 封装的一个跨平台 rm -rf 工具
    - friendly-errors-webpack-plugin 友好的 webpack 错误提示
    - @babel/core @babel/plugin-transform-runtime @babel/preset-env babel-loader Babel 相关工具
    - vue-loader vue-template-compiler 处理 .vue 资源
    - file-loader 处理字体资源
    - css-loader 处理 CSS 资源
    - url-loader 处理图片资源

### 8.构建配置-webpack 配置文件

> 配置文件及打包命令

- 初始化 webpack 打包配置文件

```javascript
build
|—— webpack.base.config.js
|—— webpack.client.config.js
|—— webpack.server.config.js
```
```javascript
// webpack.base.config.js
/**
 * 公共配置
 */
const VueLoaderPlugin = require('vue-loader/lib/plugin')
const path = require('path')
const FriendlyErrorsWebpackPlugin = require('friendly-errors-webpack-plugin')
const resolve = file => path.resolve(__dirname, file)

const isProd = process.env.NODE_ENV === 'production'

module.exports = {
  mode: isProd ? 'production' : 'development',
  output: {
    path: resolve('../dist/'),
    publicPath: '/dist/',
    filename: '[name].[chunkhash].js'
  },
  resolve: {
    alias: {
      // 路径别名，@ 指向 src
      '@': resolve('../src/')
    },
    // 可以省略的扩展名
    // 当省略扩展名的时候，按照从前往后的顺序依次解析
    extensions: ['.js', '.vue', '.json']
  },
  devtool: isProd ? 'source-map' : 'cheap-module-eval-source-map',
  module: {
    rules: [
      // 处理图片资源
      {
        test: /\.(png|jpg|gif)$/i,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192,
            },
          },
        ],
      },

      // 处理字体资源
      {
        test: /\.(woff|woff2|eot|ttf|otf)$/,
        use: [
          'file-loader',
        ],
      },

      // 处理 .vue 资源
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      },

      // 处理 CSS 资源
      // 它会应用到普通的 `.css` 文件
      // 以及 `.vue` 文件中的 `<style>` 块
      {
        test: /\.css$/,
        use: [
          'vue-style-loader',
          'css-loader'
        ]
      },
      
      // CSS 预处理器，参考：https://vue-loader.vuejs.org/zh/guide/pre-processors.html
      // 例如处理 Less 资源
      // {
      //   test: /\.less$/,
      //   use: [
      //     'vue-style-loader',
      //     'css-loader',
      //     'less-loader'
      //   ]
      // },
    ]
  },
  plugins: [
    new VueLoaderPlugin(),
    new FriendlyErrorsWebpackPlugin()
  ]
}

```
```javascript
// webpack.client.config.js
/**
 * 客户端打包配置
 */
const { merge } = require('webpack-merge')
const baseConfig = require('./webpack.base.config.js')
const VueSSRClientPlugin = require('vue-server-renderer/client-plugin')

module.exports = merge(baseConfig, {
  entry: {
    app: './src/entry-client.js'
  },

  module: {
    rules: [
      // ES6 转 ES5
      {
        test: /\.m?js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
            cacheDirectory: true,
            plugins: ['@babel/plugin-transform-runtime']
          }
        }
      },
    ]
  },

  // 重要信息：这将 webpack 运行时分离到一个引导 chunk 中，
  // 以便可以在之后正确注入异步 chunk。
  optimization: {
    splitChunks: {
      name: "manifest",
      minChunks: Infinity
    }
  },

  plugins: [
    // 此插件在输出目录中生成 `vue-ssr-client-manifest.json`。
    new VueSSRClientPlugin()
  ]
})

```
```javascript
// webpack.server.config.js
/**
 * 服务端打包配置
 */
const { merge } = require('webpack-merge')
const nodeExternals = require('webpack-node-externals')
const baseConfig = require('./webpack.base.config.js')
const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')

module.exports = merge(baseConfig, {
  // 将 entry 指向应用程序的 server entry 文件
  entry: './src/entry-server.js',

  // 这允许 webpack 以 Node 适用方式处理模块加载
  // 并且还会在编译 Vue 组件时，
  // 告知 `vue-loader` 输送面向服务器代码(server-oriented code)。
  target: 'node',

  output: {
    filename: 'server-bundle.js',
    // 此处告知 server bundle 使用 Node 风格导出模块(Node-style exports)
    libraryTarget: 'commonjs2'
  },

  // 不打包 node_modules 第三方包，而是保留 require 方式直接加载
  externals: [nodeExternals({
    // 白名单中的资源依然正常打包
    allowlist: [/\.css$/]
  })],

  plugins: [
    // 这是将服务器的整个输出构建为单个 JSON 文件的插件。
    // 默认文件名为 `vue-ssr-server-bundle.json`
    new VueSSRServerPlugin()
  ]
})

```

### 9.构建配置-配置构建命令

```json
// package.json
  "scripts": {
    "build:client": "cross-env NODE_ENV=production webpack --config build/webpack.client.config.js",
    "build:server": "cross-env NODE_ENV=production webpack --config build/webpack.server.config.js",
    "build": "rimraf dist && npm run build:client && npm run build:server",
    "start": "cross-env NODE_ENV=production node server.js",
    "dev": "node server.js"
  },
```
### 10.构建配置-启动应用

```javascript
// server.js
const Vue = require('vue)
const express = require('express')
cosnst fs = require('fs')

const serverBundle = require('./dist/vue-ssr-server-bundle.json')
const template = fs.readFileSync('./index.template.html', 'utf-8')
const clientManifest = require('./dist/vue-ssr-client-manifest.json')

const renderer = require('vue-server-renderer').createBundleRenderer(serverBundle,{
  template,
  clientManifest
})

const server = express()

server.get('/',(req,res)=>{
  renderer.renderToString(app, {
    title: 'XXXX',
    meta: `<meta name="description" content="XXXX"`
  }，(err,html)=>{
    if(err) {
      return res.status(500).end('Internal Server Error.')
    }
    // res.setHeader('Content-Type','text/html;charset=utf8')
    res.end(html)
  })
})
server.listen(3000,()=>{
  console.log('server running at port 3000.)
})
```

### 11.构建配置-解析渲染流程
### 12.构建配置开发模式-基本思路
### 13.构建配置开发模式-提取处理模块
### 14.构建配置开发模式-updata 更新函数
### 15.构建配置开发模式-处理模板文件
### 16.构建配置开发模式-服务器监视打包
### 17.构建配置开发模式-把数据写入内存中
### 18.构建配置开发模式-客户端构建
### 19.构建配置开发模式-热更新
### 20.编写通用应用注意事项
### 21.路由处理-配置 VueRouter
### 22.路由处理-将路由注册到根实例
### 23.路由处理-适配服务端入口
### 24.路由处理-服务端 server 适配
### 25.路由处理-适配客户端入口
### 26.路由处理-处理完成
### 27.管理页面 Head 内容
### 28.数据预取和状态管理-思路分析
### 29.数据预取和状态管理-数据预取
### 30.数据预取和状态管理-将预取数据同步到客户端

## 任务二：静态站点生成

### 1.Gridsome基础-介绍
### 2.Gridsome基础-创建 Gridsome 项目
### 3.Gridsome基础-预渲染
### 4.Gridsome基础-目录结构
### 5.Gridsome基础-项目配置
### 6.Gridsome基础-Pages
### 7.Gridsome基础-添加集合
### 8.Gridsome基础-在 GraphQL 中查询数据
### 9.Gridsome基础-在页面中查询 GraphQL
### 10.Gridsome基础-使用模板渲染节点页面
### 11.Gridsome案例-创建项目
### 12.Gridsome案例-处理首页模板
### 13.Gridsome案例-处理其它页面模板
### 14.Gridsome案例-使用本地md文件管理文章内容
### 15.Gridsome案例-Strapi介绍
### 16.Gridsome案例-Strapi基本使用
### 17.Gridsome案例-使用Strapi接口数据
### 18.Gridsome案例-访问受保护的API
### 19.Gridsome案例-通过GraphQL访问Strapi
### 20.Gridsome案例-将Strapi数据预取到Gridsome应用中
### 21.Gridsome案例-设计文章和标签数据模型
### 22.Gridsome案例-展示文章列表
### 23.Gridsome案例-文章列表分页
### 24.Gridsome案例-展示文章详情
### 25.Gridsome案例-处理Markdown格式的文章内容
### 26.Gridsome案例-文章标签
### 27.Gridsome案例-基本设置
### 28.Gridsome案例-联系我
### 29.Gridsome案例-部署Strapi
### 30.Gridsome案例-把本地服务联通远程Strapi
### 31.Gridsome案例-部署Gridsome应用

## 任务三：封装 Vue.js 组件库

### 1.课程目标

> 开源组件库

- Element-UI
- iView

> CDD

- CDD(Component-Driven Development)
  - 自下而上
  - 从组件级别开始，到页面级别结束

> CDD 的好处

- 组件在最大程度被重用
- 并行开发
- 可视化测试

> 课程介绍

- 处理组件边界情况
- 快速原型开发
- 组件开发
- Storybook
- Monorepo
- 基于模板生成包的结构
- Lerna + yarn workspaces
- 组件测试
- Rollup 打包

### 2.处理组件的边界情况

- $root
- $parent/$children
- $refs
- 依赖注入provide/inject

### 3.attrs-listeners

- $attrs
  - 把父组件中非 prop 属性绑定到内部组件
- $listeners
  - 把父组件中的 DOM 对象的原生事件绑定到内部组件

### 4.快速原型开发

> 快速原型开发

- VueCLI 中提供了一个插件可以进行原型快速开发
- 需要先额外安装一个全局的扩展
  - npm install -g @vue/cli-service-global
- 使用 vue serve 快速查看组件的运行效果

> vue serve

- vue serve 如果不指定参数默认会在当前目录找以下入口文件
  - main.js、index.js、App.vue、app.vue

- 可以指定要加载的组件
  - vue serve ./src/login.vue

### 5.快速原型开发-ElementUI

> 安装 ElementUI

- 初始化 package.json
  - npm init -y
- 安装 ElementUI
  - vue add element
- 加载 ElementUI，使用 Vue.use() 安装插件

### 6.组件开发-步骤条组件

> 组件分类

- 第三方组件
- 基础组件
- 业务组件

### 7.组件开发-表单组件-上

> 整体结构

- Form
- FormItem
- Input
- Button

### 8.组件开发-表单组件-下

略

### 9.组件开发-表单组件-表单验证-上

- npm install async-validator

```vue
// Form
<template>
  <form>
    <slot></slot>
  </form>
</template>
<、script>
export default {
    name:'LgForm',
    provide(){
        return {
            form: this
        }
    },
    props: {
        model: {
            type: Object
        },
        rules: {
            type: Object
        }
    }
}
</、script>

// FormItem
<template>
  <div>
    <label>{{label}}<label>
    <div>
      <slot></slot>
      <p v-if="errMessage">{{errMessage}}</p>
    </div>
  </div>
</template>
<、script>
import AsyncValidator from 'async-validator'
export default {
    name:'LgFormItem',
    inject:['form'],
    props: {
        label: {
            type: String
        },
        prop: {
            type: String
        }
    },
    mounted(){
        this.$on('validate',()=>{
            this.validate()
        })
    },
    data(){
        return {
            errMessage: ''
        }
    },
    methods: {
        validate(){
            if(!this.prop) return
            const value = this.form.model[this.prop]
            const rules = this.form.rules[this.prop]
            
            const descriptor = {[this.prop]:rules}
            const validator = new AsyncValidator(descriptor)
            return validator.validate({[this.prop]:value},errors => {
                if(errors){
                    this.errMessage = errors[0].message
                }else{
                    this.errMessage = ''
                }
            })
        }
    }
}
</、script>
```

### 10.组件开发-表单组件-表单验证-下

> Input 组件验证

- Input 组件中触发自定义事件 validate
- FormItem 渲染完毕注册自定义事件 validate

```vue

// Input
<template>
  <div>
    <input v-bind="$attrs" :type="type" :value="value" @input="handleInput">
  </div>
</template>
<、script>

export default {
    name:'LgInput',
    inheritAttrs: false,
    props: {
        value: {
            type: String
        },
        type: {
            type: String,
            default: 'text'
        }
    },
    methods: {
        handleInput(evt) {
            this.$emit('input', evt.target.value)
            const findParent = parent => {
                while (parent) {
                    if(parent.$options.name === 'LgFormItem') {
                        break
                    } else {
                        parent = parent.$parent
                    }
                }
                return parent
            }
            const parent = findParent(this.$parent)
            if (parent) {
                parent.$emit('validate')
            }
        }
    }
}
</、script>

// Button
<template>
  <div>
    <button @click="handleClick"><slot></slot></button>
  </div>
</template>
<、script>
export default {
  name: 'LoButton',
  methods: {
    handleClick(evt) {
      this.$emit('click',evt)
      evt.preventDefault()
    }
  }
}
</、script>
```

### 11.Monorepo

> 两种项目的组织方式

- Multirepo(Multiple Repository)
  - 每一个包对应一个项目

- Monorepo(Monolithic Repository)
  - 一个项目仓库中管理多个模块/包

### 12.Storybook上

> Storybook

- 可视化的组件展示平台
- 在隔离的开发环境中，以交互式的方式展示组件
- 独立开发组件
- 支持的框架
  - React、React Native、Vue、Angular
  - Ember、HTML、Svelte、Mithril、Riot

> Storybook 安装

- 自动安装
  - npx -p @storybook/cli sb init --type vue
  - yarn add vue
  - yarn add vue-loader vue-template-compiler --dev
- 手动安装

### 13.Storybook下

略

### 14.yarn workspaces

> 开启 yarn 的工作区

- 项目根目录的 package.json

```javascript
"privite": true,
"workspaces": [
  "./packages/*"
]
```

> yarn workspaces 使用

- 给工作区根目录安装开发依赖
  - yarn add jest -D -W

- 给指定工作区安装依赖
  - yarn workspace lg-button add lodash@4

- 给所有工作区安装依赖
  - yarn install

### 15.Lerna上

> Lerna 介绍

- Lerna 是一个优化使用 git 和 npm 管理多包仓库的工作流工具
- 用于管理具有多个包的 JavaScript 项目
- 它可以一键把代码提交到 git 和 npm 仓库

> lerna 使用

- 全局安装
  - yarn global add lerna

- 初始化
  - lerna init

- 发布
  - lerna publish

### 16.Lerna下

略

### 17.Vue组件的单元测试

> 组件单元测试好处

- 提供描述组件行为的文档
- 节省手动测试的时间
- 减少研发新特性时产生的 bug
- 改进设计
- 促进重构

> 安装依赖

- Vue Test Utils
- Jest
- vue-jest
- babel-jest
- 安装
  - yarn add jest @vue/test-utils vue-jest babel-jest -D -W
  
### 18.Vue组件的单元测试 2

> Jest 常用 API

- 全局函数
  - describe(name, fn) 把相关测试组合在一起
  - test(name, fn) 测试方法
  - expect(value) 断言

- 匹配器
  - toBe(value) 判断值是否相等
  - toEqual(obj) 判断对象是否相等
  - toContain(value) 判断数组或者字符串中是否包含

- 快照
  - toMatchSnapshot()

> Vue Test Utils 常用 API

- mount()
  - 创建一个包含被挂载和渲染的 Vue 组件的 Wrapper

- Wrapper
  - vm wrapper 包裹的组件实例
  - props() 返回 Vue 实例选项中的 props 对象
  - html() 组件生成的 HTML 标签
  - find() 通过选择器返回匹配到的组件中的 DOM 元素
  - trigger() 触发 DOM 原生事件，自定义事件 wrapper.vm.$emit()

### 19.Rollup打包上

> Rollup

- Rollup 是一个模块打包器
- Rollup 支持 Tree-shaking
- 打包的结果比 Webpack 要小
- 开发框架/组件库的时候使用 Rollup 更合适

> 安装依赖

- Rollup
- rollup-plugin-terser
- tollup-plugin-vue@5.1.9
- vue-template-compiler

### 20.Rollup打包下

略

### 21.设置环境变量

- yarn add cross-env -D -W

### 22.清理

- yarn add rimraf -D -W

### 23.基于模板生成组件基本结构

- yarn plop -W -D

### 24.基于模板生成组件基本结构2

略

### 25.发布

略
