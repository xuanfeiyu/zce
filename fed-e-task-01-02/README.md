# Part 1 · JavaScript 深度剖析

## 模块二 · ES 新特性与 TypeScript、JS 性能优化

## 简答题

### 一、请说出下列最终的执行结果,并解释为什么

```javascript
var a = [];
for(var i = 0;i < 10; i++) {
    a[i] = function() {
        console.log(i)
    }
}
a[6]()
```

答：10

首先该段代码在全局作用域中声明了个空数组 a，然后 for 循环时是使用 var 定义循环变量 i (存在变量提升)，且 i++ 并不是重新定义了一个变量，只是对 i 变量重新赋值了，最终循环结束时 i 等于10，由于 function(){console.log(i)} 并没有立即执行，所以等 for 循环执行结束后，所有的 a[i] 输出的都是 10。

### 二、请说出下列最终的执行结果,并解释为什么

```javascript
var tmp = 123;
if(true) {
    console.log(tmp)
    let tmp
}
```

答：Uncaught ReferenceError: Cannot access 'tmp' before initialization

该代码片段中，首先在全局作用域中声明了个全局变量tmp并赋值为 123，但是块级作用域内 let 又声明了一个局部变量 tmp，导致 tmp 绑定在这个块级作用域，并且 let 没有变量提升，所以在let声明变量前，对tmp使用会报错。

### 三、结合 ES6 新语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```

答：

```javascript
var arr = [12, 34, 32, 89, 4]
console.log(Math.min(...arr))
```

### 四、请详细说明var,let,const三种声明变量方式之间的具体差别

答：
> var

- 用 var 声明的变量的作用域是它当前的执行上下文
- 会变量提升

> let

- let会产生块级作用域，不会出现变量提升的情况

> const

- 恒量/常量
- let基础上多了**只读**
- 声明过后不允许再被修改（不允许声明过后重新指向一个新的内存地址，并不是说不允许修改恒量中的属性成员）

### 五、请说出下列代码最终输出的结果，并解释为什么

```javascript
var a = 10;
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a)
        })
    }
}
obj.fn()
```

答：20

首先全局变量a的值是10，obj对象里面由两个key分别时a和fn，a的值时100，fn则是一个函数，函数体里面时一个setTimeout，setTimeout第一个参数是箭头函数，箭头函数里面执行打印this.a。因为箭头函数不会创建自己的this，它只会从自己作用域链的上一层继承this，所以这里的this指向的是obj对象，打印出来的结果是20。

### 六、简述 Symbol 类型的用途

答：

- 为对象创建独一无二的key值
- 可以模拟对象的私有属性
- 可以用作常量

### 七、说说什么是浅拷贝，什么是深拷贝

答：

- 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

- 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟出一个新的区域存放新对象，且修改新对象不会影响原对象。

### 八、请简述 TypeScript 与 JavaScript 之间的关系

答：

- TypeScript 是 JavaScript 的超集/扩展集，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，并扩展了 JavaScript 的语法。
- TypeScript 可以使用 JavaScript 中的所有代码和编码概念，TypeScript 是为了使 JavaScript 的开发变得更加容易而创建的。
- TypeScript 从核心语言方面和类概念方面对 JavaScript 对象模型进行扩展。
- JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。
- TypeScript 通过类型注解提供编译时的静态类型检查。
- TypeScript 中的数据要求带有明确的类型，JavaScript不要求。
- TypeScript 为函数提供了缺省参数值。
- TypeScript 引入了 JavaScript 中没有的“类”概念。
- TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。

### 九、请谈谈你所认为的 TypeScipt 优缺点

> 优点

- 增加了代码的可读性和可维护性
- 包容，js 文件可以直接改成 ts 文件、不定义类型可自动推论类型、ts 编译报错时也可以生成 js 文件、兼容第三方库
- 拥有活跃的社区

> 缺点

- 增加学习成本，需要理解接口和泛型、类、枚举类型
- 短期增加开发成本，毕竟要多写一些类型定义
- 集成到构建流程需要一定的工作量
- 和有些库结合时不是很完美

### 十、描述引用计数的工作原理和优缺点

答：

> 工作原理

- 核心思想：设置引用数，判断当前引用数是否为 0
- 引用计数器
- 引用关系改变时修改引用数字
- 引用数字为 0 时立即回收

> 引用计数算法优点

- 发现垃圾时立即回收
- 最大限度减少程序暂停

> 引用计数算法缺点

- 无法回收循环引用的对象
- 时间开销大

### 十一、描述标记整理算法的工作流程

答：

- 标记整理可以看做是标记清除的增强
- 标记阶段的操作和标记清除一致
- 清除阶段会先执行整理，移动对象位置

### 十二、描述V8中新生代存储区垃圾回收的流程

答：

> V8 内存分配

- V8 内存空间一分为二
- 小空间用于存储新生代对象(32M|16M)
- 新生代指的是存活时间较短的对象

> 新生代对象回收实现

- 回收过程采用复制算法 + 标记整理
- 新生代内存区分为二个等大小空间
- 使用空间为 From，空闲空间为 To
- 活动对象存储于 From 空间
- 标记整理后将活动对象拷贝至 To
- From 与 To 交换空间完成释放

> 回收细节说明

- 拷贝过程中可能出现晋升
- 晋升就是将新生代对象移动至老生代
- 一轮 GC 还存活的新生代需要晋升
- To 空间的使用率超过 25%

### 十三、描述增量标记算法在何时使用及工作原理

答：

- 在清除老生代对象时为提高清除效率优化时使用

- 工作原理：

  - 遍历对象进行标记
  - 分段（交替）进行增量标记，跟程序交替执行
  - 标记完成后，进行清除操作，完成垃圾回收
