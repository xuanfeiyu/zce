# Part 2 ·模块二 ES 新特性与 TypeScript、JS 性能优化

## 简答题

### 一、请说出下列最终的执行结果,并解释为什么。

```javascript
var a = [];
for(var i = 0;i < 10; i++) {
    a[i] = function() {
        console.log(i)
    }
}
a[6]()
```
答：10 i是全局作用域，循环执行完i被累加到10
### 二、请说出下列最终的执行结果,并解释为什么。

```javascript
var tmp = 123;
if(true) {
    console.log(tmp)
    let tmp
}
```
答：Uncaught ReferenceError: Cannot access 'tmp' before initialization  let不会变量提升
### 三、结合 ES6 新语法，用最简单的方式找出数组中的最小值。

```javascript
var arr = [12, 34, 32, 89, 4]
```

答：

```javascript
var arr = [12, 34, 32, 89, 4]
console.log(Math.min(...arr))
```

### 四、请详细说明var,let,const三种声明变量方式之间的具体差别。
答：
> var

- 用 var 声明的变量的作用域是它当前的执行上下文
- 会变量提升

> let

- let会产生块级作用域，不会出现变量提升的情况

> const

- 恒量/常量
- let基础上多了**只读**
- 声明过后不允许再被修改（不允许声明过后重新指向一个新的内存地址，并不是说不允许修改恒量中的属性成员）

### 五、请说出下列代码最终输出的结果，并解释为什么。

```javascript
var a = 10;
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a)
        })
    }
}
obj.fn()
```

答：20  箭头函数不会改变this指向

### 六、简述 Symbol 类型的用途。

答：最主要的作用就是为对象添加独一无二的属性名

### 七、说说什么是浅拷贝，什么是深拷贝。

答：
- 浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。
如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

- 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟出一个新的区域存放新对象，且修改新对象不会影响原对象。

### 八、请简述 TypeScript 与 JavaScript 之间的关系。

### 九、请谈谈你所认为的 TypeScipt 优缺点。

### 十、描述引用计数的工作原理和优缺点。

答：

> 工作原理

- 核心思想：设置引用数，判断当前引用数是否为 0
- 引用计数器
- 引用关系改变时修改引用数字
- 引用数字为 0 时立即回收

> 引用计数算法优点

- 发现垃圾时立即回收
- 最大限度减少程序暂停

> 引用计数算法缺点

- 无法回收循环引用的对象
- 时间开销大

### 十一、描述标记整理算法的工作流程。

答：

- 标记整理可以看做是标记清除的增强
- 标记阶段的操作和标记清除一致
- 清除阶段会先执行整理，移动对象位置


### 十二、描述V8中新生代存储区垃圾回收的流程。

答：

> V8 内存分配

- V8 内存空间一分为二
- 小空间用于存储新生代对象(32M|16M)
- 新生代指的是存活时间较短的对象

> 新生代对象回收实现

- 回收过程采用复制算法 + 标记整理
- 新生代内存区分为二个等大小空间
- 使用空间为 From，空闲空间为 To
- 活动对象存储于 From 空间
- 标记整理后将活动对象拷贝至 To
- From 与 To 交换空间完成释放

> 回收细节说明

- 拷贝过程中可能出现晋升
- 晋升就是将新生代对象移动至老生代
- 一轮 GC 还存活的新生代需要晋升
- To 空间的使用率超过 25%


### 十三、描述增量标记算法在何时使用及工作原理。

