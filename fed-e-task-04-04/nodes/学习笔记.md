# Part 4 · React 框架原理与实战

## 模块四 · React 服务端渲染专题（原生实现、Next.js 集成框架、Gatsby）

## 任务一：ReactSSR

### 1.ReactSSR相关观念回顾

> 什么是客户端渲染

CSR：Client Side Rendering

服务端仅返回 JSON 数据，DATA 和 HTML 在客户端进行渲染.

> 什么是服务器端渲染

SSR：Server Side Rendering

服务器端返回 HTML，DATA和HTML在服务器端进行渲染.

> 客户端渲染存在的问题

1.首屏等待时间长，用户体验差
2.页面结构为空，不利于SEO

> React SSR 同构

同构指的是代码复用，即实现客户端和服务端最大程度的代码复用.


### 2.项目结构初始化

- react-ssr
  - src 源代码文件夹
    - client 客户端代码
    - server 服务端代码
    - share 同构代码

### 3.实现ReactSSR雏形

> 创建 Node 服务器

```js
import express from 'express';
const app = express();
app.use(express.static('public'));
app.listen(3000,()=>console.log("server is listening on 3000 port"));
export default app;
```

> 实现 React SSR

1.引入要渲染的 React 组件
2.通过 renderToString 方法将 React 组件转换为 HTML 字符串
3.将结果HTML字符串响应到客户端

renderToString 方法用于将 React 组件转换为 HTML 字符串，通过 react-dom/server 导入

### 4.服务器端程序webpack打包配置

> webpack 打包配置

问题：Node 环境不支持 ESModule 模块系统，不支持 JSX 语法.

> 项目启动命令配置

1.配置服务端打包命令："dev:server-build":"webpack --config webpack.server.js --watch"
2.配置服务端启动命令："dev:server-run":"nodemon --watch build --exec\"node build/bundle.js\""

### 5.为组件元素附加事件的方式

> 实现思路分析

在客户端对组件进行二次“渲染”，为组件元素附加事件。

> 客户端二次“渲染”hydrate

使用 hydrate 方法对组件进行渲染，为组件元素附加事件.
hydrate 方法在实现渲染的时候，会复用原本已经存在的DOM节点，减少重新生成节点以及删除原本DOM节点的开销.
通过 react-dom 导入 hydrate.

```js
ReactDOM.hydrate(<App />,document.QuerySelector("#root"))
```

> 客户端 React 打包配置

1.webpack 配置

打包目的：转换 JSX 语法，转换浏览器不识别的高级 JavaScript 语法
打包目标位置：public 文件夹

2.打包启动命令配置

"dev:client-build":"webpack --config webpack.client.js --watch"

> 添加客户端包文件请求链接

在响应给客户端的 HTML 代码中添加 script 标签，请求客户端 JavaScript 打包文件.

```html
<htmL>
  <head>
    <title>React SSR</title>
  </head>
  <body>
    <div id="root">${content}</div>
    <script src="bundle.js"></script>
  </body>
</html>
```

> 服务端实现静态资源访问

服务端程序实现静态资源访问功能，客户端 JavaScript 打包文件会被作为静态资源使用.

```js
app.use(express.static('public'));
```

### 6.优化：合并webpack配置

服务端 webpack 配置和客户端 webpack 配置存在重复，将重复配置抽象到 webpack.base.js 配置文件中.

```js
const merge = require('webpack-merge');
const baseConfig = require('./webpack.base');
const config = { ... }
module.exporets = merge(baseConfig,config);
```

### 7.优化：合并项目启动命令

目的：使用一个命令启动项目，解决多个命令启动的繁琐问题，通过 npm-run-all 工具实现.

```js
"dev": "npm-run-all --parallel dev:*"
```

### 8.优化：服务器端打包文件体积优化
### 9.优化：代码拆分
### 10.实现服务器端路由
### 11.实现客户端路由
### 12.实现客户端Redux
### 13.实现服务器端Redux(一)
### 14.实现服务器端Redux(二)
### 15.实现服务器端Redux(三)
### 16.防止XSS攻击

## 任务二：Next

### 1.Next.js整体介绍
### 2.创建Next项目
### 3.基于页面的路由系统-创建页面
### 4.基于页面的路由系统-页面跳转
### 5.Next应用中的静态资源访问
### 6.修改页面中的元数据
### 7.Next应用中添加样式的方式
### 8.预渲染介绍
### 9.实现静态生成
### 10.实现服务器端渲染
### 11.实现基于动态路由的静态生成
### 12.fallback选项的作用
### 13.自定义404页面
### 14.API Routes
### 15.案例代码初始化配置
### 16.实现头部组件布局
### 17.实现导航组件布局
### 18.实现轮播图组件布局
### 19.电影列表布局
### 20.电影详情页面布局
### 21.实现首页组件的静态生成：轮播图数据获取与展示
### 22.实现首页组件的静态生成：电影列表数据的获取与展示
### 23.实现详情页基于动态路由的静态生成
### 24.导出静态网站
### 25.自定义Next应用服务器
### 26.部署Next应用到Vercel平台

## 任务三：Gatsby

### 1.什么是Gatsby以及静态应用的优势
### 2.Gatsby工作流程与框架特性
### 3.创建Gatsby项目
### 4.基于文件的路由系统
### 5.以编程的方式创建页面
### 6.Link组件的使用
### 7.GraphQL数据层介绍
### 8.在组件中从数据层中查询数据
### 9.Gatsby框架中和插件相关的一些概念
### 10.将本地JSON文件数据添加到数据层中
### 11.图像优化
### 12.将本地markdown文件作为数据源构建文章列表
### 13.以编程方式为所有md数据节点添加slug属性
### 14.根据slug构建文章详情页
### 15.解决markdown文件中的图片显示优化问题
### 16.将CMS作为Gatsby应用程序的外部数据源
### 17.开发数据源插件-获取外部数据
### 18.开发数据源插件-添加数据至数据层
### 19.开发数据转换插件
### 20.SEO优化
### 21.让Gatsby应用支持less
### 22.案例实现方式介绍
### 23.创建realworld项目
### 24.构建案例所需组件
### 25.在案例中配置Redux
### 26.实现登录（一）
### 27.实现登录（二）
### 28.同步用户状态
### 29.实现客户端路由
### 30.受保护的客户端路由
### 31.文章列表实现思路分析
### 32.通过数据源插件获取外部文章列表数据
### 33.将文章列表数据添加至数据层
### 34.根据文章列表数据创建带分页的文章列表页面
### 35.组件查询数据显示数据-1
### 36.动态获取文章列表数据
### 37.创建文章详情页面
### 38.创建动态文章详情页面

