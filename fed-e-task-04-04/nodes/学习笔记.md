# Part 4 · React 框架原理与实战

## 模块四 · React 服务端渲染专题（原生实现、Next.js 集成框架、Gatsby）

## 任务一：ReactSSR

### 1.ReactSSR相关观念回顾

> 什么是客户端渲染

CSR：Client Side Rendering

服务端仅返回 JSON 数据，DATA 和 HTML 在客户端进行渲染.

> 什么是服务器端渲染

SSR：Server Side Rendering

服务器端返回 HTML，DATA和HTML在服务器端进行渲染.

> 客户端渲染存在的问题

1.首屏等待时间长，用户体验差
2.页面结构为空，不利于SEO

> React SSR 同构

同构指的是代码复用，即实现客户端和服务端最大程度的代码复用.


### 2.项目结构初始化

- react-ssr
  - src 源代码文件夹
    - client 客户端代码
    - server 服务端代码
    - share 同构代码

### 3.实现ReactSSR雏形

> 创建 Node 服务器

```js
import express from 'express';
const app = express();
app.use(express.static('public'));
app.listen(3000,()=>console.log("server is listening on 3000 port"));
export default app;
```

> 实现 React SSR

1.引入要渲染的 React 组件
2.通过 renderToString 方法将 React 组件转换为 HTML 字符串
3.将结果HTML字符串响应到客户端

renderToString 方法用于将 React 组件转换为 HTML 字符串，通过 react-dom/server 导入

### 4.服务器端程序webpack打包配置

> webpack 打包配置

问题：Node 环境不支持 ESModule 模块系统，不支持 JSX 语法.

> 项目启动命令配置

1.配置服务端打包命令："dev:server-build":"webpack --config webpack.server.js --watch"
2.配置服务端启动命令："dev:server-run":"nodemon --watch build --exec\"node build/bundle.js\""

### 5.为组件元素附加事件的方式

> 实现思路分析

在客户端对组件进行二次“渲染”，为组件元素附加事件。

> 客户端二次“渲染”hydrate

使用 hydrate 方法对组件进行渲染，为组件元素附加事件.
hydrate 方法在实现渲染的时候，会复用原本已经存在的DOM节点，减少重新生成节点以及删除原本DOM节点的开销.
通过 react-dom 导入 hydrate.

```js
ReactDOM.hydrate(<App />,document.QuerySelector("#root"))
```

> 客户端 React 打包配置

1.webpack 配置

打包目的：转换 JSX 语法，转换浏览器不识别的高级 JavaScript 语法
打包目标位置：public 文件夹

2.打包启动命令配置

"dev:client-build":"webpack --config webpack.client.js --watch"

> 添加客户端包文件请求链接

在响应给客户端的 HTML 代码中添加 script 标签，请求客户端 JavaScript 打包文件.

```html
<htmL>
  <head>
    <title>React SSR</title>
  </head>
  <body>
    <div id="root">${content}</div>
    <script src="bundle.js"></script>
  </body>
</html>
```

> 服务端实现静态资源访问

服务端程序实现静态资源访问功能，客户端 JavaScript 打包文件会被作为静态资源使用.

```js
app.use(express.static('public'));
```

### 6.优化：合并webpack配置

服务端 webpack 配置和客户端 webpack 配置存在重复，将重复配置抽象到 webpack.base.js 配置文件中.

```js
const merge = require('webpack-merge');
const baseConfig = require('./webpack.base');
const config = { ... }
module.exporets = merge(baseConfig,config);
```

### 7.优化：合并项目启动命令

目的：使用一个命令启动项目，解决多个命令启动的繁琐问题，通过 npm-run-all 工具实现.

```js
"dev": "npm-run-all --parallel dev:*"
```

### 8.优化：服务器端打包文件体积优化

问题：在服务端打包文件中，包含了 Node 系统模块，导致打包文件本身体积庞大.
解决：通过 webpack 配置剔除打包文件中的 Node 模块.

```js
// webpack.server.js
const nodeExternals = require('webpack-node-exteernals');
const config = {
    externals: [nodeExternals()]
}
```

### 9.优化：代码拆分

> 将启动服务器代码和渲染代码进行模块化拆分

优化代码组织方式，渲染 React 组件代码是独立功能，所以把它从服务器端入口文件中进行抽离.

### 10.实现服务器端路由

> 实现思路分析

在 React SSR 项目中需要实现两端路由.
客户端路由是用于支持用户通过点击链接的形式跳转页面.
服务端路由是用于支持用户直接从浏览器地址栏中访问页面.
客户端和服务端公用一套路由规则.

> 编写路由规则

```js
import HomePage from './pages/HomePage';
import ListPage from './pages/ListPage';
export default [{
    path: '/',
    component: HomePage,
    exact: true
},{
    path: '/list',
    ...ListPage
}]
```

> 实现服务端路由

1.Express 路由接收任何请求

Express 路由接收所有 GET 请求，服务端 React 路由通过请求路径匹配要进行渲染的组件.

```js
app.get("*“， async(req, res) => {});
```

> 实现服务端路由

2.服务端路由配置

```js
import { StaticRouter } from "react-router-dom";
import { renderRoutes } from "react-router-config";

export default req = {
    const content = renderToString(
        <StaticRouter location={req.path}>
          {renderRoutes(routes)}
        </StaticRouter>
    )
}
```

### 11.实现客户端路由

2.添加客户端路由配置

```js
import { BrowserRouter } from "react-router-dom";
import { renderRoutes } from "react-router-config";
import routes from "../share/routes";

ReactDOM.hydrate(
    <BrowsRouter>{renderRoutes(routes)}</BrowsRouter>,
    document.querySelector('#root')
)
```

### 12.实现客户端Redux

> 实现思路分析

在实现了 React SSR 的项目中需要实现两端 Redux.
客户端 Redux 就是通过客户端 JavaScript 管理 Store 中的数据.
服务器端 Redux 就是在服务器端搭建一套 Redux 代码，用于管理组件中的数据.
客户端和服务器端共用一套 Reducer 代码.
创建 Store 的代码由于参数传递不同所以不可以共用.

### 13.实现服务器端Redux(一)

1.创建 Store

```js
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import reducers from '../share/store/reducers';

expport default () => createStore(reducers, {}, apllyMiddleware(thunk));
```

2.配置 Store

```js
app.get("*", async(req, res) => {
    const store = createStore();
    res.send(renderer(req,store))
})
```

```js
import { Provider } from 'react-redux';
export default (req, store) => {
  const content = renderToString(
      <Provider store={store}>
        <StaticRouter location={req.path}>
          {renderRoutes(routes)}
        </StaticRouter>
      </Provider>
  );
}
```

### 14.实现服务器端Redux(二)

> 服务器端 store 数据填充

问题：服务器端创建的 store 是空的，组件并不能从 Store 中获取到任何数据.
解决：服务器端在渲染组件之前获取到组件所需要的数据.

1.在组件中添加 loadData 方法，此方法用于获取组件所需数据，方法被服务器端调用.
2.将 loadData 方法保存在当前组件的路由信息对象中.
3.服务器端在接收到请求后，根据请求地址匹配出要渲染的组件的路由信息.
4.从路由信息中获取组件中的 loadData 方法并调用方法获取组件所需数据.
5.当数据获取完成以后再渲染组件并将结果响应到客户端.

### 15.实现服务器端Redux(三)

> React 警告消除

警告原因：客户端 Store 在初始状态下是没有数据的，在渲染组件的时候生成的是空 ul，但是服务器端是先获取数据再进行组件渲染，所以生成的是有子元素的ul，hydrate 方法在对比的时候发现两者不一致，所以报了警告.
解决思路：将服务器端获取到的数据回填给客户端，让客户端拥有初始数据.

1.服务器响应 Store 初始状态

```js
const initialState = store.getState();
<body>
  <div id="root">${content}</div>
  <script>window.INITIAL_STATE = ${initialState}</script>
  <script src="bundle.js"></script>
</body>
```

2.客户端设置 Store 初始状态

```js
const store = createStore(
    reducers,
    window.INITIAL_STATE,
    applyMiddleware(thunk)
)
```

### 16.防止XSS攻击

转义状态的恶意代码

```js
let reaponse = {
    data: [{id: 1, name: "</script><script>alert(1)</script>"}]
}
import serialize from 'serialaze-javascript';
const initialState = serialize(store.getState());
```

## 任务二：Next

### 1.Next.js整体介绍

Next.js 是 React 服务端渲染应用框架，用于构建 SEO 友好的 SPA 应用.

1.支持两种预渲染方式，静态生成和服务端渲染.
2.基于页面的路由系统，路由零配置.
3.自动代码拆分，优化页面加载速度.
4.支持静态导出，可将应用导出为静态网站.
5.内置CSS-in-JS库styled-jsx.
6.方案成熟，可用于生产环境，世界许多公司都在使用.
7.应用部署简单，拥有专属部署环境 Vercel，也可以部署在其他环境.

### 2.创建Next项目

创建：npm init next-app next-guide
运行：npm run dev
访问：localhost:3000

临时安装 create-next-app 用于创建 Next.js 项目

### 3.基于页面的路由系统-创建页面

在 Next.js 中，页面是被放置在 pages 文件夹中的 React 组件.
组件需要被默认导出.
组件文件中不需要引入 React.
页面地址与文件地址是对应的关系.

```js
// pages/list.js
export default function List() {
    return <div>List page works</div>
}
```

pages/index.js       /
pages/list.js        /list
pages/post/first.js  /post/first

### 4.基于页面的路由系统-页面跳转

> 页面跳转

Link 组件默认使用 JavaScript 进行页面跳转，既 SPA 形式的跳转.
如果浏览器中 JavaScript 被禁用，则使用链接跳转.
Link 组件中不应该添加出 href 属性以外的属性，其余属性添加到a标签上.
Link 组件通过预取（在生产中）功能自动优化应用程序以获得最佳性能.

```js
import Link from 'next/link';
<Link href="/list"><a title="list page">list page</a></Link>
```

### 5.Next应用中的静态资源访问

> 静态资源

应用程序根目录中的 public 文件夹用于提供静态资源.

通过以下形式进行访问.
public/images/1.jpg -> /images/1.jpg
public/css/base.css -> /css/base.css

### 6.修改页面中的元数据

通过 Head 组件修改元数据.

```js
import Head from 'next/head';
<>
  <Head>
    <title>Index Page</title>
  </Head>
</>
```

### 7.Next应用中添加样式的方式

> 内置 style-jsx
在 Next.js 中内置了 style-jsx,它是一个 CSS-in-JS，允许在 React 组件中编写CSS，CSS仅作用于组件内部.

```js
<Link href="/list">
  <a className="Demo">jump to list page</a>
<Link>
<style jsx>{`
.demo {
    color: red;
}
`}
```

### 8.预渲染介绍
### 9.实现静态生成
### 10.实现服务器端渲染
### 11.实现基于动态路由的静态生成
### 12.fallback选项的作用
### 13.自定义404页面
### 14.API Routes
### 15.案例代码初始化配置
### 16.实现头部组件布局
### 17.实现导航组件布局
### 18.实现轮播图组件布局
### 19.电影列表布局
### 20.电影详情页面布局
### 21.实现首页组件的静态生成：轮播图数据获取与展示
### 22.实现首页组件的静态生成：电影列表数据的获取与展示
### 23.实现详情页基于动态路由的静态生成
### 24.导出静态网站
### 25.自定义Next应用服务器
### 26.部署Next应用到Vercel平台

## 任务三：Gatsby

### 1.什么是Gatsby以及静态应用的优势
### 2.Gatsby工作流程与框架特性
### 3.创建Gatsby项目
### 4.基于文件的路由系统
### 5.以编程的方式创建页面
### 6.Link组件的使用
### 7.GraphQL数据层介绍
### 8.在组件中从数据层中查询数据
### 9.Gatsby框架中和插件相关的一些概念
### 10.将本地JSON文件数据添加到数据层中
### 11.图像优化
### 12.将本地markdown文件作为数据源构建文章列表
### 13.以编程方式为所有md数据节点添加slug属性
### 14.根据slug构建文章详情页
### 15.解决markdown文件中的图片显示优化问题
### 16.将CMS作为Gatsby应用程序的外部数据源
### 17.开发数据源插件-获取外部数据
### 18.开发数据源插件-添加数据至数据层
### 19.开发数据转换插件
### 20.SEO优化
### 21.让Gatsby应用支持less
### 22.案例实现方式介绍
### 23.创建realworld项目
### 24.构建案例所需组件
### 25.在案例中配置Redux
### 26.实现登录（一）
### 27.实现登录（二）
### 28.同步用户状态
### 29.实现客户端路由
### 30.受保护的客户端路由
### 31.文章列表实现思路分析
### 32.通过数据源插件获取外部文章列表数据
### 33.将文章列表数据添加至数据层
### 34.根据文章列表数据创建带分页的文章列表页面
### 35.组件查询数据显示数据-1
### 36.动态获取文章列表数据
### 37.创建文章详情页面
### 38.创建动态文章详情页面

