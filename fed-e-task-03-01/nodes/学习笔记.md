# Part 3 · Vue.js 框架源码与进阶

## 模块一 · 手写 Vue Router、手写响应式实现、虚拟 DOM 和 Diff 算法

## 任务一：Vue.js 基础回顾

### 1.阶段内容

- 快速回顾 Vue.js 基础语法
- Vue Router 原理分析与实现
- 虚拟 DOM 库 Snabbdom 源码解析
- 响应式原理分析与实现
- Vue.js 源码分析

### 2.Vue 基础结构

略

### 3.Vue 的生命周期

略

### 4.Vue 语法和概念-上

- 插值表达式
- 指令
- 计算属性和侦听器
- Class 和 Style 绑定
- 条件渲染/列表渲染
- 表单输入绑定

### 5.Vue 语法和概念-下

- 组件
- 插槽
- 插件
- 混入 mixin
- 深入响应式原理
- 不同构建版本的 Vue

## 任务二：Vue-Router 原理实现

### 1.课程介绍

- Vue Router 基础回顾
- Hash 模式和 History 模式
- 模拟实现自己的Vue Router

### 2.Vue Router 基础回顾-使用步骤

略

### 3.动态路由

略

### 4.嵌套路由

略

### 5.编程式导航

- push
- replace
- go

### 6.Hash 模式和 History 模式的区别

- 表现形式的区别
  - Hash 模式
    - https:music.163.com/#/palylist?id=3102961863
  - History 模式
    - https:music.163.com/palylist/3102961863

- 原理的区别
  - Hash 模式是基于锚点，以及 onhashchange事件
  - History 模式是基于 HTML5 中的 History API
    - history.pushState() IE10 以后才支持
    - history.repalceState()

### 7.History 模式

- History 需要服务器的支持
- 单页应用中，服务端不存在 http://www.testurl.com/login 这样的地址会返回找不到该页面
- 在服务端应该除了静态资源外都返回单页应用的 index.html

### 8.History 模式 - Node.js

```javascript
const path = require('path')
const history = require('connect-history-api-fallback')
const express = require('express')
const app = express()
app.use(history())
app.use(express.static(path.join(__dirname, '../web')))
app.listen(3000, () => {
  console.log('服务器开启， 端口：3000')
})
```

### 9.History 模式 - nginx

- 从官网下载 nginx 的压缩包
- 把压缩包解压到 c 盘根目录， c:\nginx-1.18.0 文件夹
- 打开命令行，切换到目录 c:\nginx-1.18.0

```javascript
// 启动
start nginx
// 重启
nginx -s reload
// 停止
nginx -s stop

// nginx
location / {
  root html;
  index index.html index.htm;
  try_files $uri $uri/ /index.html;
}
```

### 10.VueRouter 实现原理

> Vue 前置知识

- 插件
- 混入
- Vue.observable()
- 插槽
- render 函数
- 运行时和完整版的 Vue

> Hash 模式

- URL 中 # 后面的内容作为路径地址
- 监听 hashchange 事件
- 根据当前路由地址找到对应组件重新渲染

> History 模式

- 通过 history.pushState() 方法改变地址栏
- 监听 popstate 事件
- 根据当前路由地址找到对应组件重新渲染

### 11.VueRouter 模拟实现 - 分析

VueRouter

- options
- data
- routeMap
- Constructor(Options): VueRouter
- _install(Vue): void
- init(): void
- initEvent(): void
- createRouterMap(): void
- initComponents(Vue): void

### 12.VueRouter - install

```javascript
let _Vue = null
export default class VueRouter {
  static install (Vue) {
    // 1.判断当前插件是否已经被安装
    if(VueRouter.install.installed){
      return
    }
    VueRouter.install.installed = true
    // 2.把 Vue 构造函数记录到全局变量
    _Vue = Vue
    // 3.把创建 Vue 实例时候传入的router对象注入到Vue实例上 
    // 混入
    _Vue.mixin({
      beforeCreate () {
        if(this.$options.router){
          _Vue.prototype.$router = this.$options.router
          this.$options.router.init() // 详见 15.VueRouter - router-link
        }
      }
    })
  }
}
```

### 13.VueRouter - 构造函数

```javascript
export default class VueRouter {
  ...
  constructor (options) {
    this.options = options
    this.routeMap = {}
    this.data = _Vue.observable({
      current: '/'
    })
  }
}
```

### 14.VueRouter - createRouteMap

```javascript
export default class VueRouter {
  ...
  createRouteMap() {
    // 遍历所有的路由规则，把路由规则解析成键值对的形式 存储到 routeMap 中
    this.options.routes.forEach(route => {
      this.routeMap[route.path] = route.component
    })
  }
}
```

### 15.VueRouter - router-link

> Vue 的构建版本

- 运行时版：不支持 template 模板，需要打包的时候提前编译
- 完整版：包含运行时和编译器，体积比运行时版大 10k 左右， 程序运行的时候把模板转换成 render 函数

```javascript
export default class VueRouter {
  ...
  initComponents(Vue) {
    Vue.component('router-link', {
      props: {
        to: String
      },
      template: '<a :href = "to"><slot></slot></a>'
    })
  }

  init() {
    this.createRouteMap()
    this.initComponents(_Vue)
    this.initEvent() // 详见 19.VueRouter - initEvent
  }
}
```

### 16.VueRouter - 完整版的 Vue

```javascript
// vue.config.js
module.exports = {
  runtimeCompiler: true
}

```

### 17.VueRouter - render

```javascript
export default class VueRouter {
  ...
  initComponents(Vue) {
    Vue.component('router-link', {
      props: {
        to: String
      },
      // template: '<a :href = "to"><slot></slot></a>'
      render(h) {
        return h('a', {
          attrs: {
            href: this.to
          }
        },[this.$slots.default])
      }
    })
  }
}
```

### 18.VueRouter - router-view

```javascript
export default class VueRouter {
  ...
  initComponents(Vue) {
    Vue.component('router-link', {
      props: {
        to: String
      },
      // template: '<a :href = "to"><slot></slot></a>'
      render(h) {
        return h('a', {
          attrs: {
            href: this.to
          },
          on: {
            click: this.clickHandler
          }
        },[this.$slots.default])
      },
      methods: {
        clickHandler(e) {
          history.pushState({},'',this.to)
          this.$router.data.current = this.to
          e.preventDefault()
        }
      }
    })
    const self = this
    Vue.component('router-view', {
      render(h){
        const component = self.routeMap[self.data.current]
        return h(component)
      }
    })
  }
}
```

### 19.VueRouter - initEvent

```javascript
export default class VueRouter {
  ...
  initEvent() {
    window.addEventListener('popstate', () => {
      this.dada.current = window.location.pathname
    })
  }
}
```

## 任务三：模拟 Vue.js 响应式原理

