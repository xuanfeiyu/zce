# Part 4 · React 框架原理与实战

## 模块五 · Angular 企业实战开发

## 任务一：Angular 基础

### 1.Angular 框架介绍

- Angular 是一个使用 HTML、CSS、TypeScript 构建客户端应用的框架，用来构建单页应用程序。
- Angular 是一个重量级的框架，内部集成了大量开箱即用的功能模块。
- Angular 为大型应用开发而设计，提供了干净且松耦合的代码组织方式，使应用程序整洁更易于维护。

### 2.Angular架构-模块

Angular 应用是由一个个模块组成的，此模块指的不是ESModule，而是 NgModule 即 Angular 模块。

NgModule 是一组相关功能的集合，专注于某个应用领域，可以将组件和一组相关代码关联起来，是应用组织代码结构的一种方式。

在 Angular 应用中至少要有一个根模块，用于启动应用程序。

NgModule 可以从其它 NgModule 中导入功能，前提是目标 NgModule 导出了该功能。

NgModule 是由 NgModule 装饰器函数装饰的类。

```javascript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

@NgModule({
  imports: [
    BrowserModule
  ]
})
export class AppModule { }
```

### 3.Angular架构-组件

组件用来描述用户界面，它由三部分组成，组件类、组件模板、组件样式，它们可以被集成在组件类文件中，也可以是三个不同的文件。

- 组件类用来编写和组件直接相关的界面逻辑，在组件类中要关联该组件的组件模板和组件样式。
- 组件模板用来编写组件的 HTML 结构，通过数据绑定标记将应用中数据和 DOM 进行关联。
- 组件样式用来编写组件的组件的外观，组件样式可以采用 CSS、LESS、SCSS、Stylus

在 Angular 应用中至少要有一个根组件，用于应用程序的启动。

组件类是由 Component 装饰器函数装饰的类。

```javascript
import { Component } from "@angular/core"

@Component({
  selector: "app-root",
  templateUrl: "./app.component.html",
  styleUrls: ["./app.component.css"]
})
export class AppComponent {
  title = "angular-test"
}
```

NgModule 为组件提供了编译的上下文环境。

```javascript
import { NgModule } from '@angular/core';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### 4.Angular架构-服务

- 服务用于放置和特定组件无关并希望跨组件共享的数据或逻辑。
- 服务出现的目的在于解耦组件类中的代码，是组件类中的代码干净整洁。
- 服务是由 Injectable 装饰器装饰的类。

```javascript
import { Injectable } from '@angular/core';

@Injectable({})
export class AppService { }
```

在使用服务时不需要在组件类中通过 new 的方式创建服务实例对象获取服务中提供的方法，以下写法错误，切记切记！！！

```javascript
import { AppService } from "./AppService"

export class AppComponent {
  let appService = new AppService()
}
```

服务的实例对象由 Angular 框架中内置的依赖注入系统创建和维护。服务是依赖需要被注入到组件中。

在组件中需要通过 constructor 构造函数的参数来获取服务的实例对象。

涉及参数就需要考虑参数的顺序问题，因为在 Angular 应用中会有很多服务，一个组件又不可能会使用到所有服务，如果组件要使用到最后一个服务实例对象，难道要将前面的所有参数都写上吗 ? 这显然不合理。

在组件中获取服务实例对象要结合 TypeScript 类型，写法如下。

```javascript
import { AppService } from "./AppService"

export class AppComponent {
  constructor (
  	private appService: AppService
  ) {}
}
```

Angular 会根据你指定的服务的类型来传递你想要使用的服务实例对象，这样就解决了参数的顺序问题。

在 Angular 中服务被设计为单例模式，这也正是为什么服务可以被用来在组件之间共享数据和逻辑的原因。

### 5.Angular架构-总结

略

### 6.使用AngularCLI创建应用

1. 安装 angular-cli：`npm install @angular/cli -g`

2. 创建应用：`ng new angular-test --minimal --inlineTemplate false`

   1. --skipGit=true
   2. --minimal=true
   3. --skip-install
   4. --style=css
   5. --routing=false
   6. --inlineTemplate
   7. --inlineStyle
   8. --prefix

3. 运行应用：`ng serve`

   1. --open=true 应用构建完成后在浏览器中运行
   2. --hmr=true 开启热更新
   3. hmrWarning=false 禁用热更新警告
   4. --port 更改应用运行端口

4. 访问应用：`localhost:4200`

### 7.Angular应用默认代码解析及应用启动过程

> main.ts

```javascript
// enableProdMode 方法调用后将会开启生产模式
import { enableProdMode } from "@angular/core"
// Angular 应用程序的启动在不同的平台上是不一样的
// 在浏览器中启动时需要用到 platformBrowserDynamic 方法, 该方法返回平台实例对象
import { platformBrowserDynamic } from "@angular/platform-browser-dynamic"
// 引入根模块 用于启动应用程序
import { AppModule } from "./app/app.module"
// 引入环境变量对象 { production: false }
import { environment } from "./environments/environment"

// 如果当前为生产环境
if (environment.production) {
  // 开启生产模式
  enableProdMode()
}
// 启动应用程序
platformBrowserDynamic()
  .bootstrapModule(AppModule)
  .catch(err => console.error(err))
```

### 8.共享模块
### 9.数据绑定
### 10.DOM对象的属性绑定和HTML标记的属性绑定
### 11.动态为元素添加类名及行内样式
### 12.事件绑定
### 13.获取原生 DOM 对象
### 14.双向数据绑定
### 15.内容投影
### 16.数据绑定的容错处理
### 17.引入全局样式的三种方式
### 18.指令介绍及结构指令ngIf的两种使用方式
### 19.属性指令hidden
### 20.结构指令ngFor的使用方式
### 21.自定义指令用法

## 任务二：Angular 深入学习

### 1.管道
### 2.自定义管道
### 3.组件通讯之向组件内部传递数据
### 4.组件通讯之组件向外部传递数据
### 5.生命周期函数之挂载阶段
### 6.生命周期函数之更新阶段
### 7.组件生命周期函数之卸载阶段
### 8.理解什么是依赖注入
### 9.Injector 的创建和使用
### 10.Provider 的使用
### 11.服务的创建与注入
### 12.服务的作用域
### 13.模板驱动表单用法 (删 dirty)
### 14.模板驱动表单中的表单分组
### 15.模板驱动型表单的验证方式
### 16.模型驱动表单的基本用法
### 17.模型驱动表单中实现表单分组
### 18.使用formArray动态创建表单
### 19.模型驱动表单内置验证规则的使用
### 20.模型驱动表单同步类型的自定义验证器（一）
### 21.模型驱动表单异步类型的自定义验证器（二）
### 22.FormBuild 创建模型表单的快捷方式
### 23.模型驱动表单练习之复选框
### 24.模型驱动表单练习之单选框
### 25.模型驱动表单常用方法介绍
### 26.路由的基本使用
### 27.路由传递参数的两种方式
### 28.定义子孙级路由
### 29.路由命名插座
### 30.导航路由
### 31.创建路由模块独立路由规则
### 32.实现路由模块懒加载
### 33.路由守卫 CanActivate
### 34.路由守卫 CanActiveChild
### 35.路由守卫 CanDeactivate
### 36.路由守卫 Resolve

## 任务三：Angular 高级

### 1.RxJS快速入门
### 2.可观察对象特性介绍
### 3.使用Subject构造函数创建可观察对象
### 4.使用BehaviorSubject创建可观察对象
### 5.使用ReplaySubject创建可观察对象
### 6.数据流、操作符介绍
### 7.辅助方法from
### 8.辅助方法forkJoin
### 9.辅助方法fromEvent和操作符pluck
### 10.辅助方法interval和操作符switchMap
### 11.操作符take、takeWhile、takeUntil
### 12.操作符节流和防抖
### 13.辅助方法of和操作符distinctUntilChanged
### 14.RxJS案例之元素拖拽
### 15.搜索案例
### 16.案例之串联请求的发送
### 17.HttpClientModule的基本使用
### 18.HttpParams类的使用
### 19.HttpHeaders类的使用
### 20.设置响应体
### 21.拦截器的使用(一)
### 22.拦截器的使用(二)
### 23.配置AngularProxy
### 24.NgRx概述
### 25.NgRx基本使用
### 26.selector的用法
### 27.Action传递参数
### 28.metaReducer机制介绍
### 29.使用Effect接收Action执行副作用
### 30.ngrx案例todo之添加任务
### 31.案例todo之展示任务
### 32.案例todo之删除任务
### 33.在todo案例中加入Entity简化实体操作
### 34.将路由状态同步到Store中
### 35.和状态相关的概念
### 36.为todo案例添加进场动画和出场动画
### 37.创建动画时的两个注意事项
### 38.定义关键帧动画
### 39.指定动画的回调函数
### 40.创建可重用动画
### 41.query方法的使用
### 42.group方法的使用
### 43.使用stagger方法实现交错动画
### 44.创建自定义状态动画
### 45.实现路由动画
